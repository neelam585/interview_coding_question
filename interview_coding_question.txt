
public class MyClass{
public MyClass(){
sysout("hi");
new MyClass();
}
private static MESSAGE = "msg";
main(){
MyClass m1 = new MyClass()
m1.MESSAGE = "Something else";
sysout(MESSAGE);
}
}


try{
system.exit(0);
return 5;
}catch(Exception exception){
exception.printstacktrace();
}finally{
return 1;
}



public class MyClass{
private static MESSAGE = "msg";
main(){
MyClass m1 = new MyClass()
m1.MESSAGE = "Something else";
sysout(MESSAGE);
}
}

=============================================================================================================================================================
1. String[] words = {"eat", "tea", "tan", "ate", "nat", "bat"};
          List<String> data = new ArrayList<>();
          for(int i =0; i<words.length; i++){
             String datas = words[i].chars().mapToObj(c->(char) c).sorted().collect(Collectors.joining());
              System.out.println(datas);
          }
//           OUTPUT
//
//                   [
//  ["eat", "tea", "ate"],
//  ["tan", "nat"],
//  ["bat"]
//]


2. stream api question:
Input:  1234567890  
Output: 1234XXXX90

3. secound heighest salary using sql

4. Input: mat[][] = [[1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]]
Output: [[3, 6, 9], 
                [2, 5, 8], 
                [1, 4, 7]]

5.For example, with prices = [7, 1, 5, 3, 6, 4], the maximum profit is 5 by buying on day 2 (price 1) and selling on day 5 (price 6). 

6. arraydata = {"java","python","sql"}
output  {"Java","Python","Sql"}

7. Valid Parentheses in an Expression
Input: s = "[{()}]"
Output: true
Explanation:  All the brackets are well-formed.

Input: s = "[()()]{}"
Output: true
Explanation: All the brackets are well-formed.

Input: s = "([]"
Output: false
Explanation: The expression is not balanced as there is a missing ')' at the end.

Input:  s = "([{]})"
Output: false
Explanation: The expression is not balanced because there is a closing ']' before the closing '}'.

8.
there are two map first we need to secound map short on basis of salary and then we need to map with first map1 on basis of name
Map<Integer, String> map1 = new HashMap<>();
 map1.put(101,"Rahul");
 map1.put(103,"Raj");
 map1.put(106,"Chinna");
 map1.put(105,"Rahim");

 Map<String, Double> map2 = new HashMap<>();
 map2.put("Chinna",50000.0);
 map2.put("Rahim",60000.0);
 map2.put("Raj",70000.0);
 map2.put("Rahul",20000.0);


Map<String,Integer> nameToInt = new HashMap<>();
for(Map.Entry<Integer,String> nametoint: map1.entrySet()){
   //System.out.println(nametoint.getKey() + nametoint.getValue());
   nameToInt.put(nametoint.getValue(),nametoint.getKey());
}

 List<Map.Entry<String,Double>> shortedMap2 = new ArrayList<>(map2.entrySet());
 shortedMap2.sort((a,b)->b.getValue().compareTo(a.getValue()));

 Map<Integer,Double> finalData = new LinkedHashMap<>();
 for(Map.Entry<String,Double> map2data: shortedMap2) {
     System.out.println(map2data.getKey()+"aaaaaa"+map2data.getValue());
     finalData.put(nameToInt.get(map2data.getKey()),map2data.getValue());


 }


 System.out.println(finalData);
which is correct
@FunctionalInterface interface A{ void test1(); } @FunctionalInterface interface B extends A{ void test2(); } @FunctionalInterface interface A{ void test1(); } interface B extends A{ void test2(); }

what is meaning of str.chars() and .mapToObj(c->(char)c)
Map<Character,Long> result = str.chars().mapToObj(c->(char)c).collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));


//        of all the persons using java 8 streams
//        Input is Map<String, List<String>>
//
//        e.g.person1, list(9875911111,9875911122)
//
//        person2, list(8759111112,8759111223)
//
//        Output is List<String>
//
//        9875911111
//
//        9875911122
//
//        8759111112
//
//        8759111223

        Map<String, List<String>> data =

                List < List < String >> res = data.entrySet().stream().map(Map.Entry::getValue).collect(Collectors.toList());

        res.stream().FlatMap()


//        You are designing a payment processing system
//        where different payment methods (CreditCard, Paypal, UPI)
//        need to be supported. How would you design
//        this using OOP principle to ensure scalability and maintainibility.


    }
}


///

   int productCost = 150;
      List<Integer>  insertedCoins = Arrays.asList(100, 100);
       Set<Integer> coinSystem =new HashSet<>();
        coinSystem.add(1);
        coinSystem.add(2);coinSystem.add(5);
        coinSystem.add(10);
        coinSystem.add(20);
        coinSystem.add(50);
        coinSystem.add(100);
        coinSystem.add(200);
        calculateMinCoinsForChange(productCost,insertedCoins,coinSystem);
    }

    public static Map<Integer, Integer> calculateMinCoinsForChange(
            Integer productCost, List<Integer> insertedCoins, Set<Integer> coinSystem) {

        // first we divide the product



        for(int coinsys: coinSystem){
            if(insertedCoins.contains(coinsys)){

            }
        }

        return new HashMap<>();



    }
