Question 1: Most Booked Hotel Room

Problem Description: Given a hotel which has 10 floors [0-9] and each floor has 26 rooms [A-Z]. You are given a sequence of rooms, where + suggests the room is booked, - the room is freed. You have to find the number of rooms that were booked.

You may assume that the list describes a correct sequence of bookings in chronological order; that is, only free rooms can be booked, and only booked rooms can be freed. 

You may assume:

N (length of input) is an integer within the range [1, 600]
Each element of array A is a string consisting of three characters: "+" or "-"; a digit "0"-"9"; and uppercase English letter "A" - "Z"
Input: ["+1A", "+3E", "-1A", "+4F", "+1A", "-3E"]
Output: 4
Explanation: 4 rooms are booked at this time.
Input: ["-1C", "-3F", "-1L", "-ZF", "-1R", "-3E"]
Output: 0
Explanation: All rooms are free.



- find volume
@FunctionalInterface
interface MyInterface<T>{
 T add(T l, T b, T h);

}

public class Demo{
public static void main(String[] args){

MyInterface<Integer> num = (a,b) -> (a*b*c);

}

}
---------------------------------------------------------------------------------
- create print method in singleton class A and calls print() in B class.

public class B extend A{

@Override
public void print(){
sout();
}
public static void main(String[] args){
             A.getInstance();


}

}

public class A {
private static A instance;

private A{ }

public static synchronized A getInstance(){
  if(instance == null){
    instance = new A();
}
return instance;

}

public void print(){
 System.out.print("print method");
} 

}
------------------------------------------------------------------------------------------
=========================================================================================================
List<String> listOfStrings = Arrays.asList(“Java”, “Python”, “C#”, “HTML”, “Kotlin”, “C++”, “COBOL”, “C”);


String res = listOfStrings.stream().sorted(Comporator.comparing(String::length).reversed()).skip(1).get();


List<Integer> numbers = List.of(1,2,3,4,5,6,7,8,9); 

numbers.stream() .map(i-> i *2) .filter(i-> i %2==0) .forEach(System.out :: println);

we need to write a logic using the interfaces

if there are two interfaces having default method can we override and overload

employee has id, name salary,dep
select dept, sum(salary) as salary_sum from employee   group by dept having salary_sum>10000;

what is distributed tracking?

String s = "hasgsddgsbabaffa";

           // h,as,gsd,dgsb,abaff,a
    //IntStream.range(0,s.length()).mapToObj(i->(char)i)

   List<Integer> list = Arrays.asList(2,3,4,12,13,18,17);
   //[2E,3O,4E,12E,13O,18E,17O]
=================================================================================
public class MyClass{
public MyClass(){
sysout("hi");
new MyClass();
}
private static MESSAGE = "msg";
main(){
MyClass m1 = new MyClass()
m1.MESSAGE = "Something else";
sysout(MESSAGE);
}
}


try{
system.exit(0);
return 5;
}catch(Exception exception){
exception.printstacktrace();
}finally{
return 1;
}



public class MyClass{
private static MESSAGE = "msg";
main(){
MyClass m1 = new MyClass()
m1.MESSAGE = "Something else";
sysout(MESSAGE);
}
}

=============================================================================================================================================================
1. String[] words = {"eat", "tea", "tan", "ate", "nat", "bat"};
          List<String> data = new ArrayList<>();
          for(int i =0; i<words.length; i++){
             String datas = words[i].chars().mapToObj(c->(char) c).sorted().collect(Collectors.joining());
              System.out.println(datas);
          }
//           OUTPUT
//
//                   [
//  ["eat", "tea", "ate"],
//  ["tan", "nat"],
//  ["bat"]
//]


2. stream api question:
Input:  1234567890  
Output: 1234XXXX90

3. secound heighest salary using sql

4. Input: mat[][] = [[1, 2, 3],
                            [4, 5, 6],
                            [7, 8, 9]]
Output: [[3, 6, 9], 
                [2, 5, 8], 
                [1, 4, 7]]

5.For example, with prices = [7, 1, 5, 3, 6, 4], the maximum profit is 5 by buying on day 2 (price 1) and selling on day 5 (price 6). 

6. arraydata = {"java","python","sql"}
output  {"Java","Python","Sql"}

7. Valid Parentheses in an Expression
Input: s = "[{()}]"
Output: true
Explanation:  All the brackets are well-formed.

Input: s = "[()()]{}"
Output: true
Explanation: All the brackets are well-formed.

Input: s = "([]"
Output: false
Explanation: The expression is not balanced as there is a missing ')' at the end.

Input:  s = "([{]})"
Output: false
Explanation: The expression is not balanced because there is a closing ']' before the closing '}'.

8.
there are two map first we need to secound map short on basis of salary and then we need to map with first map1 on basis of name
Map<Integer, String> map1 = new HashMap<>();
 map1.put(101,"Rahul");
 map1.put(103,"Raj");
 map1.put(106,"Chinna");
 map1.put(105,"Rahim");

 Map<String, Double> map2 = new HashMap<>();
 map2.put("Chinna",50000.0);
 map2.put("Rahim",60000.0);
 map2.put("Raj",70000.0);
 map2.put("Rahul",20000.0);


Map<String,Integer> nameToInt = new HashMap<>();
for(Map.Entry<Integer,String> nametoint: map1.entrySet()){
   //System.out.println(nametoint.getKey() + nametoint.getValue());
   nameToInt.put(nametoint.getValue(),nametoint.getKey());
}

 List<Map.Entry<String,Double>> shortedMap2 = new ArrayList<>(map2.entrySet());
 shortedMap2.sort((a,b)->b.getValue().compareTo(a.getValue()));

 Map<Integer,Double> finalData = new LinkedHashMap<>();
 for(Map.Entry<String,Double> map2data: shortedMap2) {
     System.out.println(map2data.getKey()+"aaaaaa"+map2data.getValue());
     finalData.put(nameToInt.get(map2data.getKey()),map2data.getValue());


 }


 System.out.println(finalData);
which is correct
@FunctionalInterface interface A{ void test1(); } @FunctionalInterface interface B extends A{ void test2(); } @FunctionalInterface interface A{ void test1(); } interface B extends A{ void test2(); }

what is meaning of str.chars() and .mapToObj(c->(char)c)
Map<Character,Long> result = str.chars().mapToObj(c->(char)c).collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));


//        of all the persons using java 8 streams
//        Input is Map<String, List<String>>
//
//        e.g.person1, list(9875911111,9875911122)
//
//        person2, list(8759111112,8759111223)
//
//        Output is List<String>
//
//        9875911111
//
//        9875911122
//
//        8759111112
//
//        8759111223

        Map<String, List<String>> data =

                List < List < String >> res = data.entrySet().stream().map(Map.Entry::getValue).collect(Collectors.toList());

        res.stream().FlatMap()


//        You are designing a payment processing system
//        where different payment methods (CreditCard, Paypal, UPI)
//        need to be supported. How would you design
//        this using OOP principle to ensure scalability and maintainibility.


    }
}


///

   int productCost = 150;
      List<Integer>  insertedCoins = Arrays.asList(100, 100);
       Set<Integer> coinSystem =new HashSet<>();
        coinSystem.add(1);
        coinSystem.add(2);coinSystem.add(5);
        coinSystem.add(10);
        coinSystem.add(20);
        coinSystem.add(50);
        coinSystem.add(100);
        coinSystem.add(200);
        calculateMinCoinsForChange(productCost,insertedCoins,coinSystem);
    }

    public static Map<Integer, Integer> calculateMinCoinsForChange(
            Integer productCost, List<Integer> insertedCoins, Set<Integer> coinSystem) {

        // first we divide the product



        for(int coinsys: coinSystem){
            if(insertedCoins.contains(coinsys)){

            }
        }

        return new HashMap<>();

  1.  Enhancements in HashMap (Java 8+)
       2.  Stack over flow error how avoid

       3. comparable and comprator
       4. when then query for update condition
       5. groupingby.tomap
       6. flatmap and map
       8. list of sting banana, groupe, apple

      9.
      
      10. cagiminiindia no of i count;

       nellam patel reverse patel neelam karna  PATEL ko puran captel karna HashMap

       Nellam captical ko remove kara ha sare element ka frequecy 



    }
two string have same content but reference are different. when we compare  reference using == sign it will give false value. how can we resolve


        int[] nums1 = {1, 3, 5, 6, 0, 0, 0};
        int[] nums2 = {2, 4, 7};

//        for(int i =0; i<nums1.length; i++){
//            if(nums1[i]==0){
//
//            }
//
//        }
//        {1, 3, 5, 6, 2, 4, 7};

        //1
        int i=0;
        int j=0;
               int l = nums1.length;
               int m = nums2.length;
               List<Integer> data = new ArrayList<>();
                while(l>i && m>j){

                    if(nums1[i]>nums2[j]){
                        checkUniquevalue(data,nums2[j]);
                        j++;
                    }else if(nums1[i]<nums2[j]){
                        checkUniquevalue(data,nums1[i]);
                        i++;
                    }

                }


        checkUniquevalue(data, int curent_data){
                if(data.empty() && data.get(data.size()-1)<curent_data ){
                    data.add(curent_data);
                }
        }

        System.out.println(nums1[i]);

    }
}
//Merge two sorted arrays nums1 and nums2 merge nums2 into nums1 as one sorted array.
//
//The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size equal to m + n) to hold additional element from nums2. Please note 0 in nums1 array is a positional value provided to fill the element from 2nd array.
//
//int[] nums1 = [1, 3, 5, 6, 0, 0, 0]
//int[] nums2 [2, 4, 7]



class CustomThread extends Buffer{

    void produce(int data) {
        ExecutorService producer = Executors.newFixedThreadPool(1);
        producer.submit(()=>{

        });

    }
}

class Buffer {
    Queue<Integer> list;
    int size;
    void produce(int data) {

    }
    void consume() {}

}

Producer: Generates data items and adds them to the shared buffer.

Consumer: Retrieves data items from the shared buffer and processes them.

Create the Program to start two threads producer and consumer so that the buffer does not overflow and underflow
